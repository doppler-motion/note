# 数据结构与算法

## 二叉树类

- 前中后的非递归？

二叉树的前序遍历，中序遍历和后序遍历都可以使用非递归的方式进行。下面分别介绍三种遍历方式的非递归实现：

前序遍历的非递归实现：

前序遍历的非递归实现主要依靠栈来实现。从根节点开始，将根节点压入栈中，然后循环执行以下步骤：

取出栈顶元素，输出该元素的值；
如果该元素的右子树不为空，则将右子树压入栈中；
如果该元素的左子树不为空，则将左子树压入栈中；

重复以上步骤，直到栈为空，所有节点已被遍历。
代码如下：

```
def preorderTraversal(root):
    if not root:
        return []
    stack, res = [root], []
    while stack:
        node = stack.pop()
        res.append(node.val)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    return res
```




中序遍历的非递归实现：

中序遍历的非递归实现也依靠栈来实现，但是实现起来相对复杂一些。具体而言，需要先将所有左子节点压入栈中，然后从栈中取出一个节点，输出该节点的值，并将该节点的右子树压入栈中，以待之后遍历。重复以上步骤，直到栈为空，所有节点已被遍历。
代码如下：

```
def inorderTraversal(root):
    if not root:
        return []
    stack, res = [], []
    node = root
    while node or stack:
        while node:
            stack.append(node)
            node = node.left
        node = stack.pop()
        res.append(node.val)
        node = node.right
    return res
```




后序遍历的非递归实现：

后序遍历的非递归实现相对前两个要更加复杂一些，需要使用到两个栈。具体而言，需要将节点按照根-右-左的顺序压入第一个栈中，然后再将第一个栈中的节点全部弹出，按照左-右-根的顺序压入第二个栈中。最后输出第二个栈中的所有节点即可。
代码如下：
```
def postorderTraversal(root):
    if not root:
        return []
    stack1, stack2, res = [root], [], []
    while stack1:
        node = stack1.pop()
        stack2.append(node)
        if node.left:
            stack1.append(node.left)
        if node.right:
            stack1.append(node.right)
    while stack2:
        res.append(stack2.pop().val)
    return res
```

总的来说，这三种二叉树遍历的非递归实现方法都可以通过借助栈来实现。在具体实现时，需要根据不同的遍历方式选择不同的压栈和弹栈顺序，从而实现对应的遍历效果。

- 层次遍历，之字遍历？

二叉树层次遍历是按照从上到下、从左到右的顺序遍历二叉树的所有节点。通常可以使用队列来实现层次遍历，从根节点开始将节点压入队列中，然后依次遍历队列中的节点，将每个节点的左右子节点压入队列中。在遍历完一层节点后，遍历下一层节点。具体的过程如下：
```
def levelOrder(root):
    if not root:
        return []
    queue, res = [root], []
    while queue:
        level_result = []
        level_size = len(queue)
        for i in range(level_size):
            node = queue.pop(0)
            level_result.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        res.append(level_result)
    return res
```

如果要进行之字遍历，可以在上述代码的基础上稍作修改。具体而言，需要在遍历每一层节点时，隔一层将遍历结果翻转即可。具体的过程如下：
```
def zigzagLevelOrder(root):
    if not root:
        return []
    queue, res = [root], []
    while queue:
        level_result = []
        level_size = len(queue)
        for i in range(level_size):
            node = queue.pop(0)
            level_result.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        if len(res) % 2 == 1:
            level_result.reverse()
        res.append(level_result)
    return res
```

例如，对于下面的二叉树：
    3
   / \
  9  20
    /  \
   15   7

二叉树层次遍历的结果为：
[[3], [9, 20], [15, 7]]

而二叉树之字形遍历的结果为：
[[3], [20, 9], [15, 7]]

- 二叉树的序列化与反序列化

二叉树的序列化是将二叉树按照某种方式转换为字符串的过程，可以用于在网络上传输二叉树，或者将二叉树存储到文件中等。二叉树的反序列化则是将序列化后的字符串转换回原来的二叉树的过程。以下我们介绍两种序列化与反序列化二叉树的常见方式。
前序遍历序列化与反序列化
前序遍历二叉树的顺序是先遍历根节点，然后遍历左子树，最后遍历右子树。因此，我们可以通过前序遍历将一个二叉树转换为字符串。
在序列化二叉树时，对于每个节点，我们先将节点的值转换为字符串并拼接到字符串序列化结果中，然后遍历左子树和右子树，递归进行序列化。如果节点为 None，则将 "null" 作为节点的值拼接到字符串序列化结果中。
下面是前序遍历序列化二叉树的Python代码实现：

```
def serialize(root):
    if not root:
        return 'null'
    return str(root.val) + ',' + serialize(root.left) + ',' + serialize(root.right)
```



在反序列化二叉树时，我们需要先将序列化字符串按照逗号分隔符拆分成字符串数组，然后依次取出每个节点的值创建对应的节点，同时递归构建左子树和右子树。如果当前的节点值为 "null"，则返回 None。
下面是前序遍历反序列化二叉树的Python代码实现：

```
def deserialize(data):
    queue = data.split(',')
    def build():
        val = queue.pop(0)
        if val == 'null':
            return None
        node = TreeNode(int(val))
        node.left = build()
        node.right = build()
        return node
    return build()
```



层次遍历序列化与反序列化
层次遍历二叉树是按照从上到下依次遍历每一层的节点，对于每一层的节点，先遍历左子树，再遍历右子树。因此，我们可以通过层次遍历将一个二叉树转换为字符串。
在序列化二叉树时，对于每个节点，我们先将节点的值转换为字符串并拼接到字符串序列化结果中，然后将左子树和右子树依次加入到队列中，再从队列中取出下一个节点进行这个过程。如果节点为 None，则将 "null" 作为节点的值拼接到字符串序列化结果中。
下面是层次遍历序列化二叉树的Python代码实现：

```
def serialize(root):
    if not root:
        return 'null'
    queue = [root]
    res = []
    while queue:
        node = queue.pop(0)
        if not node:
            res.append('null')
            continue
        res.append(str(node.val))
        queue.append(node.left)
        queue.append(node.right)
    return ','.join(res)
```



在反序列化二叉树时，我们需要先将序列化字符串按照逗号分隔符拆分成字符串数组，然后首先取出第一个节点的值创建对应的节点作为根节点，将其加入到队列中。然后从队列中取出下一个节点，创建对应的节点作为左子节点，将其加入到队列中，然后从队列中取出下一个节点，创建对应的节点作为右子节点，将其加入到队列中。依次类推，直到队列为空。
下面是层次遍历反序列化二叉树的Python代码实现：

```
def deserialize(data):
    if data == 'null':
        return None
    queue = data.split(',')
    root = TreeNode(int(queue.pop(0)))
    nodes = [root]
    while queue:
        node = nodes.pop(0)
        val = queue.pop(0)
        if val != 'null':
            node.left = TreeNode(int(val))
            nodes.append(node.left)
        if queue:
            val = queue.pop(0)
            if val != 'null':
                node.right = TreeNode(int(val))
                nodes.append(node.right)
    return root
```



使用以上两种方式进行序列化与反序列化操作时，需要注意以下几点：

序列化结果不唯一，同一个二叉树可能会有多种不同的序列化结果。
序列化和反序列化是对应的过程，序列化方式和反序列化方式必须相同，否则无法正确还原二叉树。

- 前中，后中遍历结果恢复二叉树

以下是使用 Python 语言实现的代码：
```
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def buildTree(preorder, inorder):
    if not preorder or not inorder:
        return None
```



    # 建立哈希表，存储中遍历结果中每个元素对应的位置
    inorder_map = {}
    for idx, val in enumerate(inorder):
        inorder_map[val] = idx
    
    root_val = preorder[0]
    root = TreeNode(root_val)
    root_idx = inorder_map[root_val]
    
    root.left = buildTree(preorder[1:1+root_idx], inorder[:root_idx])
    root.right = buildTree(preorder[1+root_idx:], inorder[root_idx+1:])
    
    return root

该函数接受两个列表作为输入，分别为前中遍历结果和后中遍历结果。首先进行边界条件的判断，如果前遍历结果或中遍历结果为空，则直接返回空节点 None。接着递归处理子树，首先找到根节点，即前遍历结果的第一个元素，然后在中遍历结果中找到该元素的位置。根据该位置，可以计算出左子树中元素的个数，然后递归处理左子树和右子树。该函数最后返回根节点 root。
在实现中，我们使用了哈希表 inorder_map 来存储中遍历结果中每个元素对应的位置。在递归过程中，可以直接查询该哈希表，避免了在中遍历结果中搜索对应元素的过程，提高了效率。

- 排序二叉树的序列化

```
以下是使用 Python 语言实现的代码：
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def serialize(root):
    if not root:
        return ''

    res = []
    stack = [(0, root)]

    while stack:
        idx, node = stack.pop()
        if node:
            # 将节点的值转换为字符串，加入结果列表
            res.append(str(node.val))
            stack.append((idx + 1, node.right))
            stack.append((idx, node.left))
        else:
            # 如果节点为空，加入占位符 '_'，方便后面反序列化
            res.append('_')

    # 用 '#' 连接结果列表，作为最终的序列化字符串
    return '#'.join(res)

def deserialize(data):
    if not data:
        return None

    # 将序列化字符串按 '#' 分割，得到每个节点的值或占位符
    values = data.split('#')

    def dfs(idx):
        if idx &gt;= len(values) or values[idx] == '_':
            return None

        # 将节点的值转换为整数，创建节点
        node = TreeNode(int(values[idx]))
        node.left = dfs(idx + 1)
        node.right = dfs(idx + 2)

        return node

    # 从根节点开始递归构建二叉树
    return dfs(0)

在序列化函数 serialize 中，我们使用了迭代的方法进行前序遍历。具体来说，我们使用一个栈 stack 来存储每个节点和它的位置。每次从栈中取出一个节点，将节点的值加入到结果列表 res 中。如果节点不为空，将其右子节点和左子节点分别入栈，注意要将右子节点放在左子节点前面，以保证前序遍历的顺序正确。如果节点为空，将占位符 '_' 加入到结果列表中。
在反序列化函数 deserialize 中，我们使用了递归的方法从根节点开始构建二叉树。具体来说，在 dfs 函数中，我们首先判断当前位置 idx 是否越界或者对应节点的值是否为占位符 '_'，如果是，则返回空节点 None。否则，我们创建一个新的节点，将节点的值赋为整数类型的 values[idx]。然后分别递归构建左子树和右子树，将左右子树的根节点分别设为当前节点的左子节点和右子节点。最后返回根节点即可。
注意，在序列化函数中，我们用符号 '_' 作为占位符，因此节点的值中不能出现该字符。在实现中，我们将节点的值转换为字符串类型，因此可以保证字符串中只包含数字字符，避免了这个问题。
```



- 二叉树的直径

一棵二叉树的直径指的是任意两个节点路径长度的最大值。也就是说，要找到这棵二叉树中的一对节点，使得它们之间的路径长度最大。这个问题可以用递归的方法来解决。
具体而言，对于某个节点，它的直径有三种情况：

经过该节点的路径是这棵树的直径。这意味着该节点的左子节点和右子节点的高度和是整棵树的最大直径。因此，我们需要计算该节点的左右子树的高度之和，并将其与整棵树的直径进行比较，更新最大直径长度。
经过该节点的路径不是这棵树的直径，但是是该节点左右子树中某个节点的子树路径直径的一部分。因此，我们需要计算该节点的左右子树的高度，并将其较大者返回。
经过该节点的路径既不是这棵树的直径，也不是该节点左右子树中某个节点的子树路径直径的一部分。因此，它的左右子树的高度都不会被用到，我们可以直接返回 0。

最终，整个问题可以用深度优先搜索的方法来求解。对于每个节点，我们计算它左右子树的高度之和，并将其与当前最大直径长度进行比较，更新最大直径长度。最后，返回该节点的高度。在实现过程中，我们可以使用一个变量来保存最大直径长度，用一个递归函数来计算树的高度。
下面是 Python 语言的实现代码：

    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    class Solution:
        def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:
            self.diameter = 0  # 记录最大直径长度
        def depth(node: TreeNode) -&gt; int:
            if not node:
                return 0
    
            left_depth = depth(node.left)  # 左子树的高度
            right_depth = depth(node.right)  # 右子树的高度
    
            # 更新最大直径长度
            self.diameter = max(self.diameter, left_depth + right_depth)
    
            # 返回当前节点的高度
            return max(left_depth, right_depth) + 1
    
        depth(root)
        return self.diameter

时间复杂度为 $O(n)$，其中 $n$ 是树中节点的个数。

- 二叉树的路径和为定值的路径

给定一棵二叉树和一个整数sum，寻找所有从根节点到叶子节点路径上的节点值之和等于sum的路径。
我们可以使用递归的方法来解决这个问题。对于每个节点，我们分别计算包括该节点和不包括该节点的路径和，递归地将问题转化为子问题。如果当前节点是叶子节点，并且经过该节点的路径和满足要求，我们将该路径添加到结果列表中。
下面是 Python 语言的实现代码：

    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    class Solution:
        def pathSum(self, root: TreeNode, targetSum: int) -&gt; List[List[int]]:
            self.res = []
        def dfs(node: TreeNode, path: List[int], path_sum: int) -&gt; None:
            if not node:
                return
    
            path.append(node.val)
            path_sum += node.val
    
            if not node.left and not node.right and path_sum == targetSum:
                self.res.append(path[:])
    
            dfs(node.left, path, path_sum)
            dfs(node.right, path, path_sum)
    
            path.pop()
    
        dfs(root, [], 0)
        return self.res

时间复杂度为 $O(n)$，其中 $n$ 是树中节点的个数。在每个节点上最多只会遍历一次，因此时间复杂度为线性的。同时，由于需要存储所有满足要求的路径，空间复杂度也为 $O(n)$。

- 翻转、复制二叉树

翻转二叉树：
给定一棵二叉树，将其翻转，即左右子树交换位置。
我们可以使用递归来解决这个问题。对于每个节点，我们交换它的左右子树，并递归的交换它的左右子树。如果当前节点为空，则返回 None。
下面是 Python 语言的实现代码：

    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    class Solution:
        def invertTree(self, root: TreeNode) -&gt; TreeNode:
            if not root:
                return None
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
    
        root.left, root.right = right, left
    
        return root

复制二叉树：
给定一棵二叉树，将其复制。复制后的每个节点包括它的所有子节点。
我们可以使用递归的方法来解决这个问题。对于每个节点，我们分别复制它的左右子树，并用复制后的左右子树建立一个新的节点。如果当前节点为空，则返回 None。
下面是 Python 语言的实现代码：

    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    class Solution:
        def copyTree(self, root: TreeNode) -&gt; TreeNode:
            if not root:
                return None
        node = TreeNode(root.val)
        node.left = self.copyTree(root.left)
        node.right = self.copyTree(root.right)
    
        return node

时间复杂度为 $O(n)$，其中 $n$ 是树中节点的个数。在每个节点上最多只会遍历一次，因此时间复杂度为线性的。同时，由于需要存储复制后的节点，空间复杂度也为 $O(n)$。

- 排序二叉树转双向链表
- 判断二叉树是否相同？判断一棵树是不是另一棵树的子树？

## 搜索回溯

- 八皇后，全排列，组合

八皇后问题是一个经典的计算机科学和数学难题，它的目标是将八个棋子放在一个8×8的棋盘上，使得任意两个棋子都不能在同一行、同一列或同一对角线上。这个问题可以通过搜索算法来解决，其中一个最简单的方法是回溯法。
全排列是指由给定个数的元素所能排列出的所有可能顺序，例如，对于三个不同的元素（1、2、3），可以有六种排列组合：123、132、213、231、312、321。全排列可以通过递归算法实现。
组合是指从给定的元素集合中选取指定数量的元素的所有可能组合。例如，对于三个不同的元素（1、2、3），从其中选择两个元素可以有三种不同的组合：{1，2}、{1，3}、{2，3}。组合也可以通过递归算法来实现，通常使用回溯法和二进制计数法两种方法。



以下是在 Python 中实现八皇后问题、全排列和组合的示例代码：
八皇后问题：

```
def queens(num=8, state=()):
    if len(state) == num - 1:
        for pos in range(num):
            if not conflict(state, pos):
                yield (pos, )
    else:
        for pos in range(num):
            if not conflict(state, pos):
                for result in queens(num, state + (pos,)):
                    yield (pos,) + result

def conflict(state, nextX):
    nextY = len(state)
    for i in range(nextY):
        if abs(state[i] - nextX) in (0, nextY - i):
            return True
    return False

print(list(queens(8)))
```



全排列：
```
def permute(data):
    if len(data) == 0:
        return []
    if len(data) == 1:
        return [data]
    res = []
    for i in range(len(data)):
        rem = data[:i] + data[i+1:]
        for p in permute(rem):
            res.append([data[i]] + p)
    return res

print(permute([1, 2, 3]))
```



组合：
```
def combinations(data, n):
    if n == 0:
        return [[]]
    res = []
    for i in range(len(data)):
        item = data[i]
        remLst = data[i+1:]
        for c in combinations(remLst, n-1):
            res.append([item]+c)
    return res

print(combinations([1, 2, 3, 4], 2))
```





- 重复数字的排列，重复数字的组合

重复数字的排列是指可以包含重复数字的全排列，例如，对于三个数字（1、2、2），可以有五种排列组合：122、212、221、112、121。实现方法可以在全排列基础上略作修改，仍然使用递归、回溯等方法。
重复数字的组合是指可以包含重复数字的组合，例如，对于三个数字（1、2、2），从其中选择两个元素可以有以下四种不同的组合：{1，2}、{1，2}、{2，2}、{2，2}。实现方法可以在组合基础上略作修改，修改枚举元素时需要注意重复的情况。
下面是在 Python 中实现重复数字的排列和组合的示例代码：
重复数字的排列：

```
def permuteUnique(nums):
    def backtrack(idx):
        if idx == n:
            res.append(nums[:])
            return
        used = set()
        for i in range(idx, n):
            if nums[i] not in used:
                used.add(nums[i])
                nums[idx], nums[i] = nums[i], nums[idx]
                backtrack(idx+1)
                nums[idx], nums[i] = nums[i], nums[idx]
    n = len(nums)
    res = []
    backtrack(0)
    return res

print(permuteUnique([1,2,2]))
```



重复数字的组合：
```
def combineWithDuplicates(candidates, target):
    def backtrack(start, target, path):
        if target == 0:
            res.append(path[:])
            return
        for i in range(start, len(candidates)):
            if i &gt; start and candidates[i] == candidates[i-1]:
                continue
            if candidates[i] &gt; target:
                break
            path.append(candidates[i])
            backtrack(i, target-candidates[i], path)
            path.pop()
    candidates.sort()
    res = []
    backtrack(0, target, [])
    return res

print(combineWithDuplicates([1,2,2,2], 4))
```



- 图的搜索

图的搜索是指在图中寻找一条从起点到目标节点的路径的过程。根据搜索的目标和方式，常见的图的搜索算法可以分为以下几种。

深度优先搜索（DFS）：深度优先搜索是一种先将当前节点的所有邻居节点都搜索一遍，直到找到目标节点或者所有路径都搜索完毕，然后回溯到上一个节点继续搜索的方法。使用栈来实现深度优先搜索。
广度优先搜索（BFS）：广度优先搜索是一种先将当前节点的所有邻居节点加入队列，然后逐个出队并继续搜索的方法。使用队列来实现广度优先搜索。
Dijkstra 算法：Dijkstra 算法是一种基于贪心策略的最短路径搜索算法，它通过维护一个到起点距离最短的节点集合和一个距离数组来计算从起点到其他节点的最短路径。使用堆来实现 Dijkstra 算法可以提高效率。
A* 算法：A* 算法是一种启发式搜索算法，它在搜索过程中使用估价函数来评估剩余路径的长度，从而尽可能快地到达目标节点。A* 算法综合了贪心策略和一些高级算法，可以在实际应用中取得良好的效果。

下面是在 Python 中实现深度优先搜索和广度优先搜索的示例代码：
深度优先搜索：

```
def dfs(graph, start):
    visited, stack = set(), [start]
    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            stack.extend(graph[vertex] - visited)
    return visited

graph = {'A': set(['B', 'C']),
         'B': set(['A', 'D', 'E']),
         'C': set(['A', 'F']),
         'D': set(['B']),
         'E': set(['B', 'F']),
         'F': set(['C', 'E'])}

print(dfs(graph, 'A'))
```



广度优先搜索：
```
from collections import deque

def bfs(graph, start):
    visited, queue = set(), deque([start])
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            queue.extend(graph[vertex] - visited)
    return visited

graph = {'A': set(['B', 'C']),
         'B': set(['A', 'D', 'E']),
         'C': set(['A', 'F']),
         'D': set(['B']),
         'E': set(['B', 'F']),
         'F': set(['C', 'E'])}

print(bfs(graph, 'A'))
```



- A star

## 概率题 

- 用rand7构造rand10



```
def rand7():
    pass  # 省略rand7函数的实现

def rand49():
    return (rand7() - 1) * 7 + rand7()

def rand40():
    n = rand49()
    while n > 40:
        n = rand49()
    return n % 10 + 1

def rand9():
    n = rand49()
    while n > 45:
        n = rand49()
    return n % 9 + 1

def rand10():
    n = rand9()
    while n == 9:
        n = rand9()
    return n
```



- 轮盘赌
- 三角形内等概论随机选点
- 等等

## 动态规划

- 编辑距离
- 背包
- LCS

## 字符串

- 给定字符串是否符合正则表达式XXX
- 给定字符串是否是数字？
- KMP
- 超大数相加

## 数组、二分、快排系列

- 旋转数组查找
- 数组中的topk

数组中的top k（最大的k个数）是指在一个数组中寻找最大的k个数。可以采用不同的算法和数据结构来实现，下面介绍两种常见的解法：快速排序和堆排序。

快速排序

快速排序是基于分治思想的排序算法，其核心思想是快速地选定一个分界值（pivot），将数组分成比pivot小的部分和比pivot大的部分，然后分别对两部分递归地进行快速排序。在本问题中，我们可以将数组partition为左半部分和右半部分，然后只递归右半部分，直到找到数组中前k大的数。
实现步骤如下：

选定一个分界值pivot
将数组partition为比pivot小和比pivot大的两部分
只递归右半部分，直到找到数组中前k大的数

时间复杂度：O(n^2)，最坏情况下需要递归n次才能找到最大的数；平均情况下需要递归logn次才能找到最大的数。
代码实现如下：

```
def quick_select(nums, k):
    if len(nums) == 0:
        return []
    pivot = nums[0]
    left = [x for x in nums if x &lt; pivot]
    right = [x for x in nums if x &gt; pivot]
    if len(right) &gt;= k:
        return quick_select(right, k)
    elif len(right) == k - 1:
        return right + [pivot]
    else:
        return quick_select(left, k - len(right) - 1) + right + [pivot]

nums = [3,2,1,5,6,4]
k = 3
print(quick_select(nums, k))

# output: [5, 6, 4]
```




堆排序

堆排序利用二叉堆的特性，可以将前k大的数维护在一个大小为k的小顶堆中，然后遍历剩余的数，将其与堆顶比较，如果比堆顶大，则将堆顶弹出，将该数插入堆中。最后堆中剩余的k个数即为数组中的前k大数。
实现步骤如下：

构建一个大小为k的小顶堆heap（下标从0开始）
遍历数组中的剩余数，如果比堆顶大，则将堆顶弹出，将该数插入堆中
返回堆中的元素

时间复杂度：O(nlogk)，因为要对增量进行logk次的插入操作，每次插入操作的时间复杂度为logk。
代码实现如下：

```
import heapq

def find_top_k(nums, k):
    heap = []
    for num in nums:
        if len(heap) &lt; k:
            heapq.heappush(heap, num)
        else:
            heapq.heappushpop(heap, num)
    return heap

nums = [3,2,1,5,6,4]
k = 3
print(find_top_k(nums, k))

# output: [4, 5, 6]
```



- 旋转打印数组
- 行列递增矩阵查找数字
- 查找出现超过一半的数字
- 查找和为定值的两个数

## 链表

- 翻转链表
- 两个链表是否有交点
- 一个链表是否有环
- 链表的倒数k个节点
- 合并链表
- 逆序打印链表

## 排序

- 各种排序的复杂度最优最差平均
- 堆排序topk
- 快排的变化

## 海量数据题

- 海量日志的出现最多的10个字符串
- 10亿个1-10的数字排序
- trie树
- hashmap
- 布隆过滤器
- bitmap

